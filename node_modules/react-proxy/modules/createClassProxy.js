'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports['default'] = proxyClass;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _createPrototypeProxy = require('./createPrototypeProxy');

var _createPrototypeProxy2 = _interopRequireDefault(_createPrototypeProxy);

var _bindAutoBindMethods = require('./bindAutoBindMethods');

var _bindAutoBindMethods2 = _interopRequireDefault(_bindAutoBindMethods);

var _deleteUnknownAutoBindMethods = require('./deleteUnknownAutoBindMethods');

var _deleteUnknownAutoBindMethods2 = _interopRequireDefault(_deleteUnknownAutoBindMethods);

var RESERVED_STATICS = ['length', 'name', 'arguments', 'caller', 'prototype', 'toString'];

function isEqualDescriptor(a, b) {
  if (!a && !b) {
    return true;
  }
  if (!a || !b) {
    return false;
  }
  for (var key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}

function proxyClass(InitialClass) {
  // Prevent double wrapping.
  // Given a proxy class, return the existing proxy managing it.
  if (Object.prototype.hasOwnProperty.call(InitialClass, '__reactPatchProxy')) {
    return InitialClass.__reactPatchProxy;
  }

  var prototypeProxy = (0, _createPrototypeProxy2['default'])();
  var CurrentClass = undefined;

  var staticDescriptors = {};
  function wasStaticModifiedByUser(key) {
    // Compare the descriptor with the one we previously set ourselves.
    var currentDescriptor = Object.getOwnPropertyDescriptor(ProxyClass, key);
    return !isEqualDescriptor(staticDescriptors[key], currentDescriptor);
  }

  var ProxyClass = undefined;
  try {
    // Create a proxy constructor with matching name
    ProxyClass = new Function('getCurrentClass', 'return function ' + (InitialClass.name || 'ProxyClass') + '() {\n        return getCurrentClass().apply(this, arguments);\n      }')(function () {
      return CurrentClass;
    });
  } catch (err) {
    // Some environments may forbid dynamic evaluation
    ProxyClass = function () {
      return CurrentClass.apply(this, arguments);
    };
  }

  // Point proxy constructor to the proxy prototype
  ProxyClass.prototype = prototypeProxy.get();

  // Proxy toString() to the current constructor
  ProxyClass.toString = function toString() {
    return CurrentClass.toString();
  };

  function update(_x) {
    var _again = true;

    _function: while (_again) {
      var NextClass = _x;
      mountedInstances = undefined;
      _again = false;

      if (typeof NextClass !== 'function') {
        throw new Error('Expected a constructor.');
      }

      // Prevent proxy cycles
      if (Object.prototype.hasOwnProperty.call(NextClass, '__reactPatchProxy')) {
        _x = NextClass.__reactPatchProxy.__getCurrent();
        _again = true;
        continue _function;
      }

      // Save the next constructor so we call it
      CurrentClass = NextClass;

      // Update the prototype proxy with new methods
      var mountedInstances = prototypeProxy.update(NextClass.prototype);

      // Set up the constructor property so accessing the statics work
      ProxyClass.prototype.constructor = ProxyClass;

      // Set up the same prototype for inherited statics
      ProxyClass.__proto__ = NextClass.__proto__;

      // Copy static methods and properties
      Object.getOwnPropertyNames(NextClass).forEach(function (key) {
        if (RESERVED_STATICS.indexOf(key) > -1) {
          return;
        }

        var staticDescriptor = _extends({}, Object.getOwnPropertyDescriptor(NextClass, key), {
          configurable: true
        });

        // Copy static unless user has redefined it at runtime
        if (!wasStaticModifiedByUser(key)) {
          Object.defineProperty(ProxyClass, key, staticDescriptor);
          staticDescriptors[key] = staticDescriptor;
        }
      });

      // Remove old static methods and properties
      Object.getOwnPropertyNames(ProxyClass).forEach(function (key) {
        if (RESERVED_STATICS.indexOf(key) > -1) {
          return;
        }

        // Skip statics that exist on the next class
        if (NextClass.hasOwnProperty(key)) {
          return;
        }

        // Skip non-configurable statics
        var descriptor = Object.getOwnPropertyDescriptor(ProxyClass, key);
        if (descriptor && !descriptor.configurable) {
          return;
        }

        // Delete static unless user has redefined it at runtime
        if (!wasStaticModifiedByUser(key)) {
          delete ProxyClass[key];
          delete staticDescriptors[key];
        }
      });

      // Try to infer displayName
      ProxyClass.displayName = NextClass.displayName || NextClass.name;

      // We might have added new methods that need to be auto-bound
      mountedInstances.forEach(_bindAutoBindMethods2['default']);
      mountedInstances.forEach(_deleteUnknownAutoBindMethods2['default']);

      // Let the user take care of redrawing
      return mountedInstances;
    }
  };

  function get() {
    return ProxyClass;
  }

  function getCurrent() {
    return CurrentClass;
  }

  update(InitialClass);

  var proxy = { get: get, update: update };

  Object.defineProperty(proxy, '__getCurrent', {
    configurable: false,
    writable: false,
    enumerable: false,
    value: getCurrent
  });

  Object.defineProperty(ProxyClass, '__reactPatchProxy', {
    configurable: false,
    writable: false,
    enumerable: false,
    value: proxy
  });

  return proxy;
}

module.exports = exports['default'];