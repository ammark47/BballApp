// Generated by CoffeeScript 1.7.1
(function() {
  var Set, helpers;

  Set = require('set');

  helpers = {};

  helpers.pxProperties = new Set(['marginTop', 'marginLeft', 'marginBottom', 'marginRight', 'paddingTop', 'paddingLeft', 'paddingBottom', 'paddingRight', 'top', 'left', 'bottom', 'right', 'translateX', 'translateY', 'translateZ', 'perspectiveX', 'perspectiveY', 'perspectiveZ', 'width', 'height', 'maxWidth', 'maxHeight', 'minWidth', 'minHeight', 'borderRadius']);

  helpers.degProperties = new Set(['rotate', 'rotateX', 'rotateY', 'rotateZ', 'skew', 'skewX', 'skewY', 'skewZ']);

  helpers.transformProperties = new Set(['translateX', 'translateY', 'translateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skew', 'skewX', 'skewY', 'skewZ', 'perspective']);

  helpers.unitForProperty = function(k, v) {
    if (typeof v !== 'number') {
      return '';
    }
    if (helpers.pxProperties.contains(k)) {
      return 'px';
    } else if (helpers.degProperties.contains(k)) {
      return 'deg';
    }
    return '';
  };

  helpers.isDefaultValueForProperty = function(k, v) {
    if (k === 'scale') {
      return v === 1;
    } else {
      return v === 0;
    }
    return false;
  };

  helpers.transformValueForProperty = function(k, v) {
    var unit;
    if (Math.abs(v) < 0.0000001) {
      v = 0;
    }
    unit = helpers.unitForProperty(k, v);
    return "" + k + "(" + v + unit + ")";
  };

  helpers.axisForTransformProperty = function(property) {
    if (property === 'perspective' || property === 'skew') {
      return ['X', 'Y'];
    } else {
      return ['X', 'Y', 'Z'];
    }
  };

  helpers.parseProperties = function(properties) {
    var axis, match, newProperties, property, value, _i, _len, _ref;
    newProperties = {};
    for (property in properties) {
      value = properties[property];
      if (helpers.transformProperties.contains(property)) {
        match = property.match(/(translate|rotate|skew|scale|perspective)(X|Y|Z|)/);
        if (match && match[2].length > 0) {
          newProperties[property] = value;
        } else {
          _ref = helpers.axisForTransformProperty(match[1]);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            axis = _ref[_i];
            newProperties[match[1] + axis] = value;
          }
        }
      } else {
        newProperties[property] = value;
      }
    }
    return newProperties;
  };

  helpers.applyFrame = function(el, properties) {
    var k, v, _results;
    if ((el.style != null)) {
      return helpers.css(el, properties);
    } else {
      _results = [];
      for (k in properties) {
        v = properties[k];
        _results.push(el[k] = v);
      }
      return _results;
    }
  };

  helpers.css = function(el, properties) {
    var k, transforms, v, _base;
    properties = helpers.parseProperties(properties);
    if (el.dynamics == null) {
      el.dynamics = {};
    }
    if ((_base = el.dynamics).style == null) {
      _base.style = {};
    }
    for (k in properties) {
      v = properties[k];
      el.dynamics.style[k] = v;
    }
    transforms = [];
    for (k in properties) {
      v = properties[k];
      if (k === 'transform') {
        transforms.push(v);
      }
      if (helpers.transformProperties.contains(k)) {
        transforms.push(helpers.transformValueForProperty(k, v));
      } else {
        el.style[helpers.support.propertyWithPrefix(k)] = "" + v + (helpers.unitForProperty(k, v));
      }
    }
    if (transforms.length > 0) {
      return el.style[helpers.support.propertyWithPrefix("transform")] = transforms.join(' ');
    }
  };

  helpers.cacheFn = function(func) {
    var cachedMethod, data;
    data = {};
    cachedMethod = function() {
      var k, key, result, _i, _len;
      key = "";
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        k = arguments[_i];
        key += k.toString() + ",";
      }
      result = data[key];
      if (!result) {
        data[key] = result = func.apply(this, arguments);
      }
      return result;
    };
    return cachedMethod;
  };

  helpers.string = {};

  helpers.string.toDashed = function(str) {
    return str.replace(/([A-Z])/g, function($1) {
      return "-" + $1.toLowerCase();
    });
  };

  helpers.support = {};

  helpers.support.prefixFor = helpers.cacheFn(function(property) {
    var k, prefix, prop, propArray, propertyName, _i, _j, _len, _len1, _ref;
    if (document.body.style[property] !== void 0) {
      return '';
    }
    propArray = property.split('-');
    propertyName = "";
    for (_i = 0, _len = propArray.length; _i < _len; _i++) {
      prop = propArray[_i];
      propertyName += prop.substring(0, 1).toUpperCase() + prop.substring(1);
    }
    _ref = ["Webkit", "Moz"];
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      prefix = _ref[_j];
      k = prefix + propertyName;
      if (document.body.style[k] !== void 0) {
        return prefix;
      }
    }
    return '';
  });

  helpers.support.propertyWithPrefix = helpers.cacheFn(function(property) {
    var prefix;
    prefix = helpers.support.prefixFor(property);
    if (prefix === 'Moz') {
      return "" + prefix + (property.substring(0, 1).toUpperCase() + property.substring(1));
    }
    if (prefix !== '') {
      return "-" + (prefix.toLowerCase()) + "-" + (helpers.string.toDashed(property));
    }
    return helpers.string.toDashed(property);
  });

  helpers.support.animationEnd = helpers.cacheFn(function() {
    var eventName, prefix;
    prefix = helpers.support.prefixFor('animation');
    if (prefix.length > 0) {
      eventName = prefix.toLowerCase() + 'AnimationEnd';
    } else {
      eventName = 'animationend';
    }
    return eventName;
  });

  module.exports = helpers;

}).call(this);
